(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/// <reference path="../../../default/typescript/typescriptAPI/TypeScriptAPIPlugin.d.ts" />
"use strict";

SupCore.system.registerPlugin("typescriptAPI", "CANNON", {
    code: "",
    defs: "/*\n// Type definitions for cannon.js\n// Initial Project: https://github.com/schteppe/cannon.js\n// Project: https://github.com/clark-stevenson/cannon.d.ts\n\nThe MIT License (MIT)\n\nCopyright (c) 2014 Clark Stevenson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\ndeclare module CANNON {\n\n    export interface IAABBOptions {\n\n        upperBound?: Vec3;\n        lowerBound?: Vec3;\n\n    }\n\n    export class AABB {\n\n        lowerBound: Vec3;\n        upperBound: Vec3;\n\n        constructor(options?: IAABBOptions);\n\n        clone() : AABB;\n        setFromPoints(points: Vec3[], position?: Vec3, quaternion?: Quaternion, skinSize?: number): void;\n        copy(aabb: AABB): void;\n        extend(aabb: AABB): void;\n        getCorners( a: Vec3, b: Vec3, c: Vec3, d: Vec3, e: Vec3, f: Vec3, g: Vec3, h: Vec3 ) : void;\n        overlaps(aabb: AABB): boolean;\n        toLocalFrame( frame: Transform, target: AABB ) : AABB;\n        toWorldFrame( frame: Transform, target: AABB ) : AABB;\n    }\n\n    export class ArrayCollisionMatrix {\n\n        matrix: Mat3[];\n\n        get(i: number, j: number): number;\n        set(i: number, j: number, value?: number): void;\n        reset(): void;\n        setNumObjects(n: number): void;\n\n    }\n\n    export class Broadphase {\n\n        world: World;\n        useBoundingBoxes: boolean;\n        dirty: boolean;\n\n        collisionPairs(world: World, p1: Body[], p2: Body[]): void;\n        needBroadphaseCollision(bodyA: Body, bodyB: Body): boolean;\n        intersectionTest(bodyA: Body, bodyB: Body, pairs1: Body[], pairs2: Body[]): void;\n        doBoundingSphereBroadphase(bodyA: Body, bodyB: Body, pairs1: Body[], pairs2: Body[]): void;\n        doBoundingBoxBroadphase(bodyA: Body, bodyB: Body, pairs1: Body[], pairs2: Body[]): void;\n        makePairsUnique(pairs1: Body[], pairs2: Body[]): void;\n        setWorld(world: World): void;\n        boundingSphereCheck(bodyA: Body, bodyB: Body): boolean;\n        aabbQuery(world: World, aabb: AABB, result: Body[]): Body[];\n\n    }\n\n    export class GridBroadphase extends Broadphase {\n\n        nx: number;\n        ny: number;\n        nz: number;\n        aabbMin: Vec3;\n        aabbMax: Vec3;\n        bins: any[];\n\n        constructor(aabbMin?: Vec3, aabbMax?: Vec3, nx?: number, ny?: number, nz?: number);\n\n    }\n\n    export class NaiveBroadphase extends Broadphase {\n    }\n\n    export class ObjectCollisionMatrix {\n\n        matrix: number[];\n\n        get(i: number, j: number): number;\n        set(i: number, j: number, value: number): void;\n        reset(): void;\n        setNumObjects(n: number): void;\n\n    }\n\n    export interface IRayIntersectWorldOptions {\n\n        mode: number;\n        result: boolean;\n        skipBackfaces: boolean;\n        collisionFilterMask: number;\n        collisionFilterGroup: number;\n        from: Vec3;\n        to: Vec3;\n        callback: Function;\n\n    }\n\n    export class Ray {\n\n        static CLOSEST: number;\n        static ANY: number;\n        static ALL: number;\n\n        from: Vec3;\n        to: Vec3;\n        precision: number;\n        checkCollisionResponse: boolean;\n        callback: Function;\n        collisionFilterGroup: number;\n        collisionFilterMask: number;\n        hasHit: boolean;\n        mode: number;\n        result: RaycastResult;\n        skipBackfaces: boolean;\n\n        constructor(from?: Vec3, to?: Vec3);\n\n        getAABB(result: RaycastResult): void;\n        intersectBodies(bodies: Body[], result?: RaycastResult): void;\n        intersectWorld(world: World, options: IRayIntersectWorldOptions): boolean;\n\n    }\n\n    export class RaycastResult {\n\n        rayFromWorld: Vec3;\n        rayToWorld: Vec3;\n        hitNormalWorld: Vec3;\n        hitPointWorld: Vec3;\n        hitFaceIndex: number;\n        hasHit: boolean;\n        shape: Shape;\n        body: Body;\n        distance: number;\n\n        abort(): void;\n        reset(): void;\n        set(rayFromWorld: Vec3, rayToWorld: Vec3, hitNormalWorld: Vec3, hitPointWorld: Vec3, shape: Shape, body: Body, distance: number): void;\n\n    }\n\n    export class SAPBroadphase extends Broadphase {\n\n        static insertionSortX(a: any[]): any[];\n        static insertionSortY(a: any[]): any[];\n        static insertionSortZ(a: any[]): any[];\n        static checkBounds(bi: Body, bj: Body, axisIndex?: number): boolean;\n\n        axisList: any[];\n        world: World;\n        axisIndex: number;\n\n        constructor(world?: World);\n\n        autoDetectAxis(): void;\n        aabbQuery(world: World, aabb: AABB, result?: Body[]): Body[];\n\n    }\n\n    export interface IConstraintOptions {\n\n        collideConnected?: boolean;\n        wakeUpBodies?: boolean;\n\n    }\n\n    export class Constraint {\n\n        equations: any[];\n        bodyA: Body;\n        bodyB: Body;\n        id: number;\n        collideConnected: boolean;\n\n        constructor(bodyA: Body, bodyB: Body, options?: IConstraintOptions);\n\n        update(): void;\n        disable(): void;\n        enable(): void;\n\n    }\n\n    export class DistanceConstraint extends Constraint {\n\n        distance: number;\n        distanceEquation: ContactEquation;\n\n        constructor(bodyA: Body, bodyB: Body, distance?: number, maxForce?: number);\n\n    }\n\n    export interface IHingeConstraintOptions {\n\n        pivotA?: Vec3;\n        axisA?: Vec3;\n        pivotB?: Vec3;\n        axisB?: Vec3;\n        maxForce?: number;\n\n    }\n\n    export class HingeConstraint extends Constraint {\n\n        axisA: Vec3;\n        axisB: Vec3;\n        rotationalEquation1: RotationalEquation;\n        rotationalEquation2: RotationalEquation;\n        motorEnabled: boolean;\n        motorTargetVelocity: number;\n        motorMinForce: number;\n        motorMaxForce: number;\n        motorEquation: RotationalMotorEquation;\n\n        constructor(bodyA: Body, bodyB: Body, options?: IHingeConstraintOptions);\n\n        enableMotor(): void;\n        disableMotor(): void;\n        setMotorMaxForce(maxForce: number): void;\n        setMotorSpeed(speed: number): void;\n\n    }\n\n    export class PointToPointConstraint extends Constraint {\n\n        equationX: ContactEquation;\n        equationY: ContactEquation;\n        equationZ: ContactEquation;\n        pivotA: Vec3;\n        pivotB: Vec3;\n\n        constructor(bodyA: Body, pivotA: Vec3, bodyB: Body, pivotB: Vec3, maxForce?: number);\n\n    }\n\n    export class ConeTwistConstraint extends PointToPointConstraint {\n\n        coneEquation: ConeEquation;\n        twistEquation: RotationalEquation;\n\n        constructor(bodyA: Body, bodyB: Body, options?: IHingeConstraintOptions);\n\n    }\n\n    export class LockConstraint extends PointToPointConstraint {\n\n        rotationalEquation1: RotationalEquation;\n        rotationalEquation2: RotationalEquation;\n        rotationalEquation3: RotationalEquation;\n\n        constructor(bodyA: Body, bodyB: Body, maxForce?: number);\n\n    }\n\n    export class Equation {\n\n        id: number;\n        minForce: number;\n        maxForce: number;\n        bi: Body;\n        bj: Body;\n        a: number;\n        b: number;\n        eps: number;\n        jacobianElementA: JacobianElement;\n        jacobianElementB: JacobianElement;\n        enabled: boolean;\n\n        constructor(bi: Body, bj: Body, minForce?: number, maxForce?: number);\n\n        setSpookParams(stiffness: number, relaxation: number, timeStep: number): void;\n        computeB(a: number, b: number, h: number): number;\n        computeGq(): number;\n        computeGW(): number;\n        computeGWlamda(): number;\n        computeGiMf(): number;\n        computeGiMGt(): number;\n        addToWlamda(deltalambda: number): number;\n        computeC(): number;\n        computeInvC( eps: number ): number;\n    }\n\n    export class FrictionEquation extends Equation {\n\n        constructor(bi: Body, bj: Body, slipForce: number);\n\n    }\n\n    export interface IRotationalEquationOptions {\n\n        axisA?: Vec3;\n        axisB?: Vec3;\n        maxForce?: number;\n\n    }\n\n    export class RotationalEquation extends Equation {\n\n        ni: Vec3;\n        nj: Vec3;\n        nixnj: Vec3;\n        njxni: Vec3;\n        invIi: Mat3;\n        invIj: Mat3;\n        relVel: Vec3;\n        relForce: Vec3;\n\n        constructor(bodyA: Body, bodyB: Body, options?: IRotationalEquationOptions);\n\n    }\n\n    export class RotationalMotorEquation extends Equation {\n\n        axisA: Vec3;\n        axisB: Vec3;\n        invLi: Mat3;\n        invIj: Mat3;\n        targetVelocity: number;\n\n        constructor(bodyA: Body, bodyB: Body, maxForce?: number);\n\n    }\n\n    export interface IConeEquationOptions {\n\n        axisA?: Vec3;\n        axisB?: Vec3;\n        maxForce?: number;\n\n    }\n\n    export class ConeEquation extends Equation {\n\n        angle: number;\n\n        constructor(bodyA: Body, bodyB: Body, options?: IConeEquationOptions);\n\n    }\n\n    export class ContactEquation extends Equation {\n\n        restitution: number;\n        ri: Vec3;\n        rj: Vec3;\n        ni: Vec3;\n\n        constructor(bi: Body, bj: Body);\n\n        getImpactVelocityAlongNormal(): number;\n\n    }\n\n    export interface IContactMaterialOptions {\n\n        friction?: number;\n        restitution?: number;\n        contactEquationStiffness?: number;\n        contactEquationRelaxation?: number;\n        frictionEquationStiffness?: number;\n        frictionEquationRelaxation?: number;\n\n    }\n\n    export class ContactMaterial {\n\n        id: number;\n        materials: Material[];\n        friction: number;\n        restitution: number;\n        contactEquationStiffness: number;\n        contactEquationRelaxation: number;\n        frictionEquationStiffness: number;\n        frictionEquationRelaxation: number;\n\n        constructor(m1: Material, m2: Material, options?: IContactMaterialOptions);\n\n    }\n\n    export class Material {\n\n        id: number;\n        name: string;\n        friction: number;\n        restitution: number;\n\n        constructor(name?: string);\n\n    }\n\n    export class JacobianElement {\n\n        spatial: Vec3;\n        rotational: Vec3;\n\n        multiplyElement(element: JacobianElement): number;\n        multiplyVectors(spacial: Vec3, rotational: Vec3): number;\n\n    }\n\n    export class Mat3 {\n\n        elements: number[];\n\n        constructor(elements?: number[]);\n\n        identity(): void;\n        setZero(): void;\n        setTrace(vec3: Vec3): void;\n        getTrace(target: Vec3): void;\n        vmult(v: Vec3, target?: Vec3): Vec3;\n        smult(s: number): void;\n        mmult(m: Mat3): Mat3;\n        scale(v: Vec3, target?: Mat3): Mat3;\n        solve(b: Vec3, target?: Vec3): Vec3;\n        e(row: number, column: number, value?: number): number;\n        copy(source: Mat3): Mat3;\n        toString(): string;\n        reverse(target?: Mat3): Mat3;\n        setRotationFromQuaternion(q: Quaternion): Mat3;\n        transpose(target?: Mat3): Mat3;\n\n    }\n\n    export class Trimesh extends Shape {\n\n        aabb: AABB;\n        edges: number[];\n        indices: number[];\n        normals: number[];\n        scale: Vec3;\n        tree: Octree;\n        vertices: number[];\n\n        static computeNormal(va: Vec3, vb: Vec3, vc: Vec3, target: Vec3): void;\n        static createTorus(radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, arc?: number): Trimesh;\n\n        constructor(vertices: number[], indices: number[]);\n\n        calculateWorldAABB(pos: Vec3, quat: Quaternion, min: Vec3, max: Vec3): void;\n        computeLocalAABB(aabb: AABB): void;\n        getEdgeVector(edgeIndex: number, vectorStore: Vec3): void;\n        getEdgeVertex(edgeIndex: number, firstOrSecond: number, vertexStore: Vec3): void;\n        getNormal(i: number, target: Vec3): Vec3;\n        getTrianglesAABB(aabb: AABB, result: number[]): void;\n        getTriangleVertices(i: number, a: Vec3, b: Vec3, c: Vec3): void;\n        getVertex(i: number, out: Vec3): Vec3;\n        getWorldVertex(i: number, pos: Vec3, quat: Quaternion, out: Vec3): Vec3;\n        setScale(scale: Vec3): void;\n        updateAABB(): void;\n        updateEdges(): void;\n        updateNormals(): void;\n        updateTree(): void;\n\n    }\n\n    export class Quaternion {\n\n        x: number;\n        y: number;\n        z: number;\n        w: number;\n\n        constructor(x?: number, y?: number, z?: number, w?: number);\n\n        set(x: number, y: number, z: number, w: number): void;\n        toString(): string;\n        toArray(): number[];\n        setFromAxisAngle(axis: Vec3, angle: number): void;\n        toAxisAngle(targetAxis?: Vec3): any[];\n        setFromVectors(u: Vec3, v: Vec3): void;\n        mult(q: Quaternion, target?: Quaternion): Quaternion;\n        inverse(target?: Quaternion): Quaternion;\n        conjugate(target?: Quaternion): Quaternion;\n        normalize(): void;\n        normalizeFast(): void;\n        vmult(v: Vec3, target?: Vec3): Vec3;\n        copy(source: Quaternion): Quaternion;\n        toEuler(target: Vec3, order?: string): void;\n        setFromEuler(x: number, y: number, z: number, order?: string): Quaternion;\n        clone(): Quaternion;\n\n    }\n\n    export class Transform {\n\n        static pointToLocalFrame(position: Vec3, quaternion: Quaternion, worldPoint: Vec3, result?: Vec3): Vec3;\n        static pointToWorldFrame(position: Vec3, quaternion: Quaternion, localPoint: Vec3, result?: Vec3): Vec3;\n        static vectorToWorldFrame(quaternion: Quaternion, localVector: Vec3, result: Vec3): Vec3;\n        static vectorToLocalFrame(position: Vec3, quaternion: Quaternion, worldVector: Vec3, result?: Vec3): Vec3;\n\n        position: Vec3;\n        quaternion: Quaternion;\n\n        pointToLocal(point: Vec3, result: Vec3): Vec3;\n        pointToWorld(point: Vec3, result: Vec3): Vec3;\n\n    }\n\n    export class Vec3 {\n\n        static ZERO: Vec3;\n        static UNIT_X: Vec3;\n        static UNIT_Y: Vec3;\n        static UNIT_Z: Vec3;\n\n        x: number;\n        y: number;\n        z: number;\n\n        constructor(x?: number, y?: number, z?: number);\n\n        cross(v: Vec3, target?: Vec3): Vec3;\n        set(x: number, y: number, z: number): Vec3;\n        setZero(): void;\n        vadd(v: Vec3, target?: Vec3): Vec3;\n        vsub(v: Vec3, target?: Vec3): Vec3;\n        crossmat(): Mat3;\n        normalize(): number;\n        unit(target?: Vec3): Vec3;\n        norm(): number;\n        norm2(): number;\n        distanceTo(p: Vec3): number;\n        distanceSquared(p: Vec3): number;\n        mult(scalar: number, target?: Vec3): Vec3;\n        scale(scalar: number, target?: Vec3): Vec3;\n        dot(v: Vec3): number;\n        isZero(): boolean;\n        negate(target?: Vec3): Vec3;\n        tangents(t1: Vec3, t2: Vec3): void;\n        toString(): string;\n        toArray(): number[];\n        copy(source: Vec3): Vec3;\n        length(): number;\n        lengthSquared(): number;\n        lerp(v: Vec3, t: number, target?: Vec3): void;\n        almostEquals(v: Vec3, precision?: number): boolean;\n        almostZero(precision?: number): boolean;\n        isAntiparallelTo(v: Vec3, prescision?: number): boolean;\n        clone(): Vec3;\n\n    }\n\n    export interface IBodyOptions {\n\n        position?: Vec3;\n        velocity?: Vec3;\n        angularVelocity?: Vec3;\n        quaternion?: Quaternion;\n        mass?: number;\n        material?: number;\n        type?: number;\n        linearDamping?: number;\n        angularDamping?: number;\n        allowSleep?: boolean;\n        sleepSpeedLimit?: number;\n        sleepTimeLimit?: number;\n        collisionFilterGroup?: number;\n        collisionFilterMask?: number;\n        fixedRotation?: boolean;\n        shape?: Body;\n\n    }\n\n    export class Body extends EventTarget {\n\n        static DYNAMIC: number;\n        static STATIC: number;\n        static KINEMATIC: number;\n        static AWAKE: number;\n        static SLEEPY: number;\n        static SLEEPING: number;\n        static sleepyEvent: IEvent;\n        static sleepEvent: IEvent;\n\n        id: number;\n        world: World;\n        preStep: Function;\n        postStep: Function;\n        vlambda: Vec3;\n        collisionFilterGroup: number;\n        collisionFilterMask: number;\n        collisionResponse: boolean;\n        position: Vec3;\n        previousPosition: Vec3;\n        initPosition: Vec3;\n        velocity: Vec3;\n        initVelocity: Vec3;\n        force: Vec3;\n        mass: number;\n        invMass: number;\n        material: Material;\n        linearDamping: number;\n        type: number;\n        allowSleep: boolean;\n        sleepState: number;\n        sleepSpeedLimit: number;\n        sleepTimeLimit: number;\n        timeLastSleepy: number;\n        torque: Vec3;\n        quaternion: Quaternion;\n        initQuaternion: Quaternion;\n        angularVelocity: Vec3;\n        initAngularVelocity: Vec3;\n        interpolatedPosition: Vec3;\n        interpolatedQuaternion: Quaternion;\n        shapes: Shape[];\n        shapeOffsets: any[];\n        shapeOrentiations: any[];\n        inertia: Vec3;\n        invInertia: Vec3;\n        invInertiaWorld: Mat3;\n        invMassSolve: number;\n        invInertiaSolve: Vec3;\n        invInteriaWorldSolve: Mat3;\n        fixedRotation: boolean;\n        angularDamping: number;\n        aabb: AABB;\n        aabbNeedsUpdate: boolean;\n        wlambda: Vec3;\n\n        constructor(options?: IBodyOptions);\n\n        wakeUp(): void;\n        sleep(): void;\n        sleepTick(time: number): void;\n        pointToLocalFrame(worldPoint: Vec3, result?: Vec3): Vec3;\n        pointToWorldFrame(localPoint: Vec3, result?: Vec3): Vec3;\n        vectorToLocalFrame(worldPoint: Vec3, result?: Vec3): Vec3;\n        vectorToWorldFrame(localVector: Vec3, result?: Vec3): Vec3;\n        addShape(shape: Shape, offset?: Vec3, orientation?: Vec3): void;\n        computeAABB(): void;\n        applyForce(force: Vec3, worldPoint: Vec3): void;\n        applyImpulse(impulse: Vec3, worldPoint: Vec3): void;\n        applyLocalForce(force: Vec3, localPoint: Vec3): void;\n        applyLocalImpulse(impulse: Vec3, localPoint: Vec3): void;\n        updateBoundingRadius(): void;\n        updateMassProperties(): void;\n        updateInertiaWorld(force: Vec3): void;\n        updateSolveMassProperties(): void;\n        getVelocityAtWorldPoint(worldPoint: Vec3, result: Vec3): Vec3;\n\n    }\n\n    export interface IWheelInfoOptions {\n\n        chassisConnectionPointLocal?: Vec3;\n        chassisConnectionPointWorld?: Vec3;\n        directionLocal?: Vec3;\n        directionWorld?: Vec3;\n        axleLocal?: Vec3;\n        axleWorld?: Vec3;\n        suspensionRestLength?: number;\n        suspensionMaxLength?: number;\n        radius?: number;\n        suspensionStiffness?: number;\n        dampingCompression?: number;\n        dampingRelaxation?: number;\n        frictionSlip?: number;\n        steering?: number;\n        rotation?: number;\n        deltaRotation?: number;\n        rollInfluence?: number;\n        maxSuspensionForce?: number;\n        isFrontWheel?: boolean;\n        clippedInvContactDotSuspension?: number;\n        suspensionRelativeVelocity?: number;\n        suspensionForce?: number;\n        skidInfo?: number;\n        suspensionLength?: number;\n        maxSuspensionTravel?: number;\n        useCustomSlidingRotationalSpeed?: boolean;\n        customSlidingRotationalSpeed?: number;\n\n        position?: Vec3;\n        direction?: Vec3;\n        axis?: Vec3;\n        body?: Body;\n\n    }\n\n    export class WheelInfo {\n\n        axleLocal: Vec3;\n        axleWorld: Vec3;\n        brake: number;\n        chassisConnectionPointLocal: Vec3;\n        chassisConnectionPointWorld: Vec3;\n        clippedInvContactDotSuspension: number;\n        customSlidingRotationalSpeed: number;\n        dampingCompression: number;\n        dampingRelaxation: number;\n        deltaRotation: number;\n        directionLocal: Vec3;\n        directionWorld: Vec3;\n        engineForce: number;\n        forwardImpulse: number;\n        frictionSlip: number;\n        isFrontWheel: boolean;\n        isInContact: boolean;\n        maxSuspensionForce: number;\n        maxSuspensionTravel: number;\n        radius: number;\n        raycastResult: RaycastResult;\n        rollInfluence: number;\n        rotation: number;\n        sideImpulse: number;\n        skidInfo: number;\n        sliding: boolean;\n        steering: number;\n        suspensionForce: number;\n        suspensionLength: number;\n        suspensionMaxLength: number;\n        suspensionRelativeVelocity: number;\n        suspensionStiffness: number;\n        suspensionRestLength: number;\n        useCustomSlidingRotationalSpeed: boolean;\n        worldTransform: Transform;\n\n        constructor(options?: IWheelInfoOptions);\n\n    }\n\n    export interface IRaycastVehicleOptions {\n\n        chassisBody?: Body;\n        indexRightAxis?: number;\n        indexLeftAxis?: number;\n        indexUpAxis?: number;\n\n    }\n\n    export class RaycastVehicle {\n\n        chassisBody: Body;\n        wheelInfos: IWheelInfoOptions[];\n        sliding: boolean;\n        world: World;\n        iindexRightAxis: number;\n        indexForwardAxis: number;\n        indexUpAxis: number;\n\n        constructor(options?: IRaycastVehicleOptions);\n\n        addWheel(options?: IWheelInfoOptions): void;\n        setSteeringValue(value: number, wheelIndex: number): void;\n        applyEngineForce(value: number, wheelIndex: number): void;\n        setBrake(brake: number, wheelIndex: number): void;\n        addToWorld(world: World): void;\n        getVehicleAxisWorld(axisIndex: number, result: Vec3): Vec3;\n        updateVehicle(timeStep: number): void;\n        updateSuspension(deltaTime: number): void;\n        updateWheelTransform(wheelIndex: number): void;\n        removeFromWorld(world: World): void;\n        getWheelTransformWorld(wheelIndex: number): Transform;\n\n    }\n\n    export interface IRigidVehicleOptions {\n\n        chassisBody: Body;\n\n    }\n\n    export class RigidVehicle {\n\n        wheelBodies: Body[];\n        coordinateSystem: Vec3;\n        chassisBody: Body;\n        constraints: Constraint[];\n        wheelAxes: Vec3[];\n        wheelForces: Vec3[];\n\n        constructor(options?: IRigidVehicleOptions);\n\n        addWheel(options?: IWheelInfoOptions): Body;\n        setSteeringValue(value: number, wheelIndex: number): void;\n        setMotorSpeed(value: number, wheelIndex: number): void;\n        disableMotor(wheelIndex: number): void;\n        setWheelForce(value: number, wheelIndex: number): void;\n        applyWheelForce(value: number, wheelIndex: number): void;\n        addToWorld(world: World): void;\n        removeFromWorld(world: World): void;\n        getWheelSpeed(wheelIndex: number): number;\n\n    }\n\n    export class SPHSystem {\n\n        particles: Particle[];\n        density: number;\n        smoothingRadius: number;\n        speedOfSound: number;\n        viscosity: number;\n        eps: number;\n        pressures: number[];\n        densities: number[];\n        neighbors: number[];\n\n        add(particle: Particle): void;\n        remove(particle: Particle): void;\n        getNeighbors(particle: Particle, neighbors: Particle[]): void;\n        update(): void;\n        w(r: number): number;\n        gradw(rVec: Vec3, resultVec: Vec3): void;\n        nablaw(r: number): number;\n\n    }\n\n    export interface ISpringOptions {\n\n        restLength?: number;\n        stiffness?: number;\n        damping?: number;\n        worldAnchorA?: Vec3;\n        worldAnchorB?: Vec3;\n        localAnchorA?: Vec3;\n        localAnchorB?: Vec3;\n\n    }\n\n    export class Spring {\n\n        restLength: number;\n        stffness: number;\n        damping: number;\n        bodyA: Body;\n        bodyB: Body;\n        localAnchorA: Vec3;\n        localAnchorB: Vec3;\n\n        constructor(options?: ISpringOptions);\n\n        setWorldAnchorA(worldAnchorA: Vec3): void;\n        setWorldAnchorB(worldAnchorB: Vec3): void;\n        getWorldAnchorA(result: Vec3): void;\n        getWorldAnchorB(result: Vec3): void;\n        applyForce(): void;\n\n    }\n\n    export class Box extends Shape {\n\n        static calculateInertia(halfExtents: Vec3, mass: number, target: Vec3): void;\n\n        halfExtents: Vec3;\n        convexPolyhedronRepresentation: ConvexPolyhedron;\n\n        constructor(halfExtents: Vec3);\n\n        updateConvexPolyhedronRepresentation(): void;\n        getSideNormals(sixTargetVectors: boolean, quat?: Quaternion): Vec3[];\n        forEachWorldCorner(pos: Vec3, quat: Quaternion, callback: Function): void;\n\n    }\n\n    export class ConvexPolyhedron extends Shape {\n\n        static computeNormal(va: Vec3, vb: Vec3, vc: Vec3, target: Vec3): void;\n        static project(hull: ConvexPolyhedron, axis: Vec3, pos: Vec3, quat: Quaternion, result: number[]): void;\n        static getFaceNormal(va: Vec3, vb: Vec3, vc: Vec3, target: Vec3): void;\n\n        vertices: Vec3[];\n        worldVertices: Vec3[];\n        worldVerticesNeedsUpdate: boolean;\n        faces: number[][];\n        faceNormals: Vec3[];\n        uniqueEdges: Vec3[];\n        uniqueAxes: Vec3[];\n\n        constructor(points?: Vec3[], faces?: number[][]);\n\n        computeEdges(): void;\n        computeNormals(): void;\n        getFaceNormal(i: number, target: Vec3): Vec3;\n        clipAgainstHull(posA: Vec3, quatA: Quaternion, hullB: Vec3, quatB: Quaternion, separatingNormal: Vec3, minDist: number, maxDist: number, result: any[]): void;\n        findSeparatingAxis(hullB: ConvexPolyhedron, posA: Vec3, quatA: Quaternion, posB: Vec3, quatB: Quaternion, target: Vec3, faceListA: any[], faceListB: any[]): boolean;\n        testSepAxis(axis: Vec3, hullB: ConvexPolyhedron, posA: Vec3, quatA: Quaternion, posB: Vec3, quatB: Quaternion): number;\n        getPlaneConstantOfFace(face_i: number): number;\n        clipFaceAgainstHull(separatingNormal: Vec3, posA: Vec3, quatA: Quaternion, worldVertsB1: Vec3[], minDist: number, maxDist: number, result: any[]): void;\n        clipFaceAgainstPlane(inVertices: Vec3[], outVertices: Vec3[], planeNormal: Vec3, planeConstant: number): Vec3;\n        computeWorldVertices(position: Vec3, quat: Quaternion): void;\n        computeLocalAABB(aabbmin: Vec3, aabbmax: Vec3): void;\n        computeWorldFaceNormals(quat: Quaternion): void;\n        calculateWorldAABB(pos: Vec3, quat: Quaternion, min: Vec3, max: Vec3): void;\n        getAveragePointLocal(target: Vec3): Vec3;\n        transformAllPoints(offset: Vec3, quat: Quaternion): void;\n        pointIsInside(p: Vec3): boolean;\n\n    }\n\n    export class Cylinder extends ConvexPolyhedron {\n\n        constructor(radiusTop: number, radiusBottom: number, height: number, numSegments: number);\n\n    }\n\n    export interface IHightfieldOptions {\n\n        minValue?: number;\n        maxValue?: number;\n        elementSize: number;\n\n    }\n\n    export class Heightfield extends Shape {\n\n        data: number[];\n        maxValue: number;\n        minValue: number;\n        elementSize: number;\n        cacheEnabled: boolean;\n        pillarConvex: ConvexPolyhedron;\n        pillarOffset: Vec3;\n        type: number;\n\n        constructor(data: number[], options?: IHightfieldOptions);\n\n        update(): void;\n        updateMinValue(): void;\n        updateMaxValue(): void;\n        setHeightValueAtIndex(xi: number, yi: number, value: number): void;\n        getRectMinMax(iMinX: number, iMinY: number, iMaxX: number, iMaxY: number, result: any[]): void;\n        getIndexOfPosition(x: number, y: number, result: any[], clamp: boolean): boolean;\n        getConvexTrianglePillar(xi: number, yi: number, getUpperTriangle: boolean): void;\n\n    }\n\n    export class Particle extends Shape {\n\n    }\n\n    export class Plane extends Shape {\n\n        worldNormal: Vec3;\n        worldNormalNeedsUpdate: boolean;\n        boundingSphereRadius: number;\n\n        computeWorldNormal(quat: Quaternion): void;\n        calculateWorldAABB(pos: Vec3, quat: Quaternion, min: number, max: number): void;\n\n    }\n\n    export class Shape {\n\n        static types: {\n\n            SPHERE: number;\n            PLANE: number;\n            BOX: number;\n            COMPOUND: number;\n            CONVEXPOLYHEDRON: number;\n            HEIGHTFIELD: number;\n            PARTICLE: number;\n            CYLINDER: number;\n\n        }\n\n        id: number;\n        type: number;\n        boundingSphereRadius: number;\n        collisionResponse: boolean;\n\n        updateBoundingSphereRadius(): number;\n        volume(): number;\n        calculateLocalInertia(mass: number, target?: Vec3): Vec3;\n\n    }\n\n    export class Sphere extends Shape {\n\n        radius: number;\n\n        constructor(radius: number);\n\n    }\n\n    export class GSSolver extends Solver {\n\n        iterations: number;\n        tolerance: number;\n\n        solve(dy: number, world: World): number;\n\n\n    }\n\n    export class Solver {\n\n        equations: Equation[];\n\n        solve(dy: number, world: World): number;\n        addEquation(eq: Equation): void;\n        removeEquation(eq: Equation): void;\n        removeAllEquations(): void;\n\n    }\n\n    export class SplitSolver extends Solver {\n\n        subsolver: Solver;\n\n        constructor(subsolver: Solver);\n\n        solve(dy: number, world: World): number;\n\n    }\n\n    export class EventTarget {\n\n        addEventListener(type: string, listener: Function): EventTarget;\n        hasEventListener(type: string, listener: Function): boolean;\n        removeEventListener(type: string, listener: Function): EventTarget;\n        dispatchEvent(event: IEvent): IEvent;\n\n    }\n\n    export class Pool {\n\n        objects: any[];\n        type: any[];\n\n        release(): any;\n        get(): any;\n        constructObject(): any;\n\n    }\n\n    export class TupleDictionary {\n\n        data: {\n            keys: any[];\n        };\n\n        get(i: number, j: number): number;\n        set(i: number, j: number, value: number): void;\n        reset(): void;\n\n    }\n\n    export class Utils {\n\n        static defaults(options?: any, defaults?: any): any;\n\n    }\n\n    export class Vec3Pool extends Pool {\n\n        static defaults(options: Object, defaults: Object): Object;\n\n        constructObject(): Vec3;\n\n    }\n\n    export class NarrowPhase {\n\n        contactPointPool: Pool[];\n        enableFrictionReduction: boolean;\n        v3pool: Vec3Pool;\n\n        convexHeightfield(convexShape: Shape, hfShape: Heightfield, convexPos: Vec3, hfPos: Vec3, convexQuat: Quaternion, hfQuat: Quaternion, convexBody: Body, hfBody: Body): void;\n        convexConvex(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body): void;\n        convexParticle(result: ContactEquation[], si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body): void;\n        convexTrimesh( result: ContactEquation[], si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body): void;\n        createContactEquation(bi: Body, bj: Body, si: Shape, sj: Shape, rsi: Shape, rsj: Shape): ContactEquation;\n        getContacts(p1: Body[], p2: Body[], world: World, result: ContactEquation[], oldcontacts: ContactEquation[]): void;\n        particlePlane( result: ContactEquation[], si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body): void;\n        particleSphere(result: ContactEquation[], si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body): void;\n        planeBox(result: ContactEquation[], si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body): void;\n        planeConvex(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body): void;\n        planeTrimesh(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body): void;\n        sphereBox(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body): void;\n        sphereConvex(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body): void;\n        sphereHeightfield(sphereShape: Shape, hfShape: Heightfield, spherePos: Vec3, hfPos: Vec3, sphereQuat: Quaternion, hfQuat: Quaternion, sphereBody: Body, hfBody: Body): void;\n        spherePlane( si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body): void;\n        sphereSphere(si: Shape, sj: Shape, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion, bi: Body, bj: Body): void;\n        sphereTrimesh(sphereShape: Shape, trimeshShape: Shape, spherePos: Vec3, trimeshPos: Vec3, sphereQuat: Quaternion, trimeshQuat: Quaternion, sphereBody: Body, trimeshBody: Body): void;\n\n    }\n\n    export interface IOctreeOptions {\n\n        root: Octree;\n        aabb: AABB;\n\n    }\n\n    export class OctreeNode {\n\n        aabb: AABB;\n        children: Octree[];\n        data: number[];\n        root: OctreeNode;\n\n    }\n\n    export class Octree extends OctreeNode {\n\n        maxDepth: number;\n\n        constructor(aabb: AABB, options: IOctreeOptions);\n\n        aabbQuery(aabb: AABB, result: Object[]): Object[];\n        insert(aabb: AABB, elementData: Object): boolean;\n        rayQuery(ray: Ray, treeTransform: Transform, result: Object[]): Object[];\n        removeEmptyNodes(): void;\n        subdivide(): void;\n\n    }\n\n    export interface IWorld {\n\n        collisisonFilterMask?: number;\n        collisionFilterGroup?: number;\n        skipBackfaces?: boolean;\n        checkCollisionResponse?: boolean;\n\n    }\n\n    export class World extends EventTarget {\n\n        dt: number;\n        allowSleep: boolean;\n        contacts: ContactEquation[];\n        frictionEquations: FrictionEquation[];\n        quatNormalizeSkip: number;\n        quatNormalizeFast: boolean;\n        time: number;\n        stepnumber: number;\n        default_dt: number;\n        nextId: number;\n        gravity: Vec3;\n        broadphase: NaiveBroadphase;\n        bodies: Body[];\n        solver: Solver;\n        constraints: Constraint[];\n        narrowPhase: NarrowPhase;\n        collisionMatrix: ArrayCollisionMatrix;\n        collisionMatrixPrevious: ArrayCollisionMatrix;\n        materials: Material[];\n        contactMaterials: ContactMaterial[];\n        contactMaterialTable: TupleDictionary;\n        defaultMaterial: Material;\n        defaultContactMaterial: ContactMaterial;\n        doProfiling: boolean;\n        profile: {\n            solve: number;\n            makeContactConstraints: number;\n            broadphaser: number;\n            integrate: number;\n            narrowphase: number;\n        };\n        subsystems: any[];\n        addBodyEvent: IBodyEvent;\n        removeBodyEvent: IBodyEvent;\n\n        addBody(body: Body): void;\n        addConstraint(c: Constraint): void;\n        addContactMaterial(cmat: ContactMaterial): void;\n        addEventListener(type: string, listener: Function): EventTarget;\n        addMaterial(m: Material): void;\n        clearForces(): void;\n        collisionMatrixTick(): void;\n        getContactMaterial(m1: Material, m2: Material): ContactMaterial;\n        numObjects(): number;\n        raycastAll(from: Vec3, to: Vec3, options: IWorld, callback: Function): boolean;\n        raycastAny(from: Vec3, to: Vec3, options: IWorld, result: RaycastResult): boolean;\n        raycastClosest(from: Vec3, to: Vec3, options: IWorld, result: RaycastResult): boolean;\n        rayTest(from: Vec3, to: Vec3, result: RaycastResult): void;\n        remove(body: Body): void;\n        removeBody(body: Body): void;\n        removeConstraint(c: Constraint): void;\n        removeEventListener(type: string, listener: Function): EventTarget;\n        step(dy: number, timeSinceLastCalled?: number, maxSubSteps?: number): void;\n\n    }\n\n    export interface IEvent {\n\n        type: string;\n\n    }\n\n    export interface IBodyEvent extends IEvent {\n\n        body: Body;\n\n    }\n\n    export class Demo {\n\n        constructor( options: Object );\n\n        addScene( title: string, initfunc: Function ): void;\n        restartCurrentScene(): void;\n\n    }\n\n}\n"
});
SupCore.system.registerPlugin("typescriptAPI", "CannonBody", {
    code: "namespace Sup {\n  export namespace Cannon {\n    export function getWorld() { return SupEngine.Cannon.World; }\n    export function resetWorld() { SupEngine.Cannon.World = new window.CANNON.World(); }\n    export function getWorldAutoUpdate() { return SupEngine.Cannon.autoUpdate; }\n    export function setWorldAutoUpdate(autoUpdate) { SupEngine.Cannon.autoUpdate = autoUpdate; }\n\n    export class Body extends ActorComponent {\n      body: any;\n\n      constructor(actor, options) {\n        super(actor);\n        this.__inner = new SupEngine.componentClasses.CannonBody(actor.__inner);\n        if (options != null) this.__inner.setup(options);\n        this.__inner.__outer = this;\n        this.body = this.__inner.body;\n        this.actor.cannonBody = this;\n      }\n      destroy() {\n        this.body = null;\n        this.actor.cannonBody = null;\n        super.destroy();\n      }\n    }\n  }\n}\n",
    defs: "declare namespace Sup {\n  namespace Cannon {\n    function getWorld(): CANNON.World;\n    function resetWorld();\n    function getWorldAutoUpdate(): boolean;\n    function setWorldAutoUpdate(autoUpdate: boolean);\n\n    class Body extends ActorComponent {\n      body: CANNON.Body;\n\n      constructor( actor: Sup.Actor, options: any );\n    }\n  }\n}\n",
    exposeActorComponent: { propertyName: "cannonBody", className: "Sup.Cannon.Body" }
});

},{}]},{},[1]);
