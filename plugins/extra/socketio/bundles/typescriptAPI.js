(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/// <reference path="../../../default/typescript/typescriptAPI/TypeScriptAPIPlugin.d.ts" />
"use strict";

SupCore.system.registerPlugin("typescriptAPI", "socketio", {
    code: "",
    defs: "// Type definitions for socket.io-client 1.4.4\n// Project: http://socket.io/\n// Definitions by: PROGRE <https://github.com/progre/>, Damian Connolly <https://github.com/divillysausages/>\n// Definitions: https://github.com/borisyankov/DefinitelyTyped\n\ndeclare var io: SocketIOClientStatic;\n\ndeclare module 'socket.io-client' {\n\texport = io;\n}\n\ninterface SocketIOClientStatic {\n\t\n\t/**\n\t * Looks up an existing 'Manager' for multiplexing. If the user summons:\n\t * \t'io( 'http://localhost/a' );'\n\t * \t'io( 'http://localhost/b' );'\n\t * \n\t * We reuse the existing instance based on the same scheme/port/host, and\n\t * we initialize sockets for each namespace. If autoConnect isn't set to\n\t * false in the options, then we'll automatically connect\n\t * @param uri The uri that we'll connect to, including the namespace, where '/' is the default one (e.g. http://localhost:4000/somenamespace)\n\t * @opts Any connect options that we want to pass along\n\t * @return A Socket object\n\t */\n\t( uri: string, opts?: SocketIOClient.ConnectOpts ): SocketIOClient.Socket;\n\t\n\t/**\n\t * Auto-connects to the window location and defalt namespace.\n\t * E.g. window.protocol + '//' + window.host + ':80/'\n\t * @opts Any connect options that we want to pass along\n\t * @return A Socket object\n\t */\n\t( opts?: SocketIOClient.ConnectOpts ): SocketIOClient.Socket;\n\t\n\t/**\n\t * @see the default constructor (io(uri, opts))\n\t */\n\tconnect( uri: string, opts?: SocketIOClient.ConnectOpts ): SocketIOClient.Socket;\n\t\n\t/**\n\t * @see the default constructor (io(opts))\n\t */\n\tconnect( opts?: SocketIOClient.ConnectOpts ): SocketIOClient.Socket;\n\t\n\t/**\n\t * The socket.io protocol revision number this client works with\n\t * @default 4\n\t */\n\tprotocol: number;\n\t\n\t/**\n\t * Socket constructor - exposed for the standalone build\n\t */\n\tSocket: SocketIOClient.Socket;\n\t\n\t/**\n\t * Manager constructor - exposed for the standalone build\n\t */\n\tManager: SocketIOClient.ManagerStatic;\n}\n\ndeclare module SocketIOClient {\n\t\n\t/**\n\t * The base emiter class, used by Socket and Manager\n\t */\n\tinterface Emitter {\n\t\t/**\n\t\t * Adds a listener for a particular event. Calling multiple times will add\n\t\t * multiple listeners\n\t\t * @param event The event that we're listening for\n\t\t * @param fn The function to call when we get the event. Parameters depend on the \n\t\t * event in question\n\t\t * @return This Emitter\n\t\t */\n\t\ton( event: string, fn: Function ):Emitter;\n\t\t\n\t\t/**\n\t\t * @see on( event, fn )\n\t\t */\n\t\taddEventListener( event: string, fn: Function ):Emitter;\n\t\t\n\t\t/**\n\t\t * Adds a listener for a particular event that will be invoked\n\t\t * a single time before being automatically removed\n\t\t * @param event The event that we're listening for\n\t\t * @param fn The function to call when we get the event. Parameters depend on\n\t\t * the event in question\n\t\t * @return This Emitter\n\t\t */\n\t\tonce( event: string, fn: Function ):Emitter;\n\t\t\n\t\t/**\n\t\t * Removes a listener for a particular type of event. This will either\n\t\t * remove a specific listener, or all listeners for this type of event\n\t\t * @param event The event that we want to remove the listener of\n\t\t * @param fn The function to remove, or null if we want to remove all functions\n\t\t * @return This Emitter\n\t\t */\n\t\toff( event: string, fn?: Function ):Emitter;\n\t\t\n\t\t/**\n\t\t * @see off( event, fn )\n\t\t */\n\t\tremoveListener( event: string, fn?: Function ):Emitter;\n\t\t\n\t\t/**\n\t\t * @see off( event, fn )\n\t\t */\n\t\tremoveEventListener( event: string, fn?: Function ):Emitter;\n\t\t\n\t\t/**\n\t\t * Removes all event listeners on this object\n\t\t * @return This Emitter\n\t\t */\n\t\tremoveAllListeners():Emitter;\n\t\t\n\t\t/**\n\t\t * Emits 'event' with the given args\n\t\t * @param event The event that we want to emit\n\t\t * @param args Optional arguments to emit with the event\n\t\t * @return Emitter\n\t\t */\n\t\temit( event: string, ...args: any[] ):Emitter;\n\t\t\n\t\t/**\n\t\t * Returns all the callbacks for a particular event\n\t\t * @param event The event that we're looking for the callbacks of\n\t\t * @return An array of callback Functions, or an empty array if we don't have any\n\t\t */\n\t\tlisteners( event: string ):Function[];\n\t\t\n\t\t/**\n\t\t * Returns if we have listeners for a particular event\n\t\t * @param event The event that we want to check if we've listeners for\n\t\t * @return True if we have listeners for this event, false otherwise\n\t\t */\n\t\thasListeners( event: string ):boolean;\n\t}\n\t\n\t/**\n\t * The Socket static interface\n\t */\n\tinterface SocketStatic {\n\t\t\n\t\t/**\n\t\t * Creates a new Socket, used for communicating with a specific namespace\n\t\t * @param io The Manager that's controlling this socket\n\t\t * @param nsp The namespace that this socket is for (@default '/')\n\t\t * @return A new Socket\n\t\t */\n\t\t( io: SocketIOClient.Manager, nsp: string ): Socket;\n\t\t\n\t\t/**\n\t\t * Creates a new Socket, used for communicating with a specific namespace\n\t\t * @param io The Manager that's controlling this socket\n\t\t * @param nsp The namespace that this socket is for (@default '/')\n\t\t * @return A new Socket\n\t\t */\n\t\tnew ( url: string, opts: any ): SocketIOClient.Manager;\n\t}\n\t\n\t/**\n\t * The Socket that we use to connect to a Namespace on the server\n\t */\n\tinterface Socket extends Emitter {\n\t\t\n\t\t/**\n\t\t * The Manager that's controller this socket\n\t\t */\n\t\tio: SocketIOClient.Manager;\n\t\t\n\t\t/**\n\t\t * The namespace that this socket is for\n\t\t * @default '/'\n\t\t */\n\t\tnsp: string;\n\t\t\n\t\t/**\n\t\t * The ID of the socket; matches the server ID and is set when we're connected, and cleared\n\t\t * when we're disconnected\n\t\t */\n\t\tid: string;\n\t\t\n\t\t/**\n\t\t * Are we currently connected?\n\t\t * @default false\n\t\t */\n\t\tconnected: boolean;\n\t\t\n\t\t/**\n\t\t * Are we currently disconnected?\n\t\t * @default true\n\t\t */\n\t\tdisconnected: boolean;\n\t\t\n\t\t/**\n\t\t * Opens our socket so that it connects. If the 'autoConnect' option for io is \n\t\t * true (default), then this is called automatically when the Socket is created\n\t\t */\n\t\topen(): Socket;\n\t\t\n\t\t/**\n\t\t * @see open();\n\t\t */\n\t\tconnect(): Socket;\n\t\t\n\t\t/**\n\t\t * Sends a 'message' event\n\t\t * @param args Any optional arguments that we want to send\n\t\t * @see emit\n\t\t * @return This Socket\n\t\t */\n\t\tsend( ...args: any[] ):Socket;\n\t\t\n\t\t/**\n\t\t * An override of the base emit. If the event is one of:\n\t\t * \tconnect\n\t\t * \tconnect_error\n\t\t * \tconnect_timeout\n\t\t * \tconnecting\n\t\t * \tdisconnect\n\t\t * \terror\n\t\t * \treconnect\n\t\t * \treconnect_attempt\n\t\t * \treconnect_failed\n\t\t * \treconnect_error\n\t\t * \treconnecting\n\t\t * \tping\n\t\t * \tpong\n\t\t * then the event is emitted normally. Otherwise, if we're connected, the\n\t\t * event is sent. Otherwise, it's buffered.\n\t\t * \n\t\t * If the last argument is a function, then it will be called\n\t\t * as an 'ack' when the response is received. The parameter(s) of the\n\t\t * ack will be whatever data is returned from the event\n\t\t * @param event The event that we're emitting\n\t\t * @param args Optional arguments to send with the event\n\t\t * @return This Socket\n\t\t */\n\t\temit( event: string, ...args: any[] ):Socket;\n\t\t\n\t\t/**\n\t\t * Disconnects the socket manually\n\t\t * @return This Socket\n\t\t */\n\t\tclose():Socket;\n\t\t\n\t\t/**\n\t\t * @see close()\n\t\t */\n\t\tdisconnect():Socket;\n\n\t\t/**\n\t\t* Sets the compress flag.\n\t\t* @param compress If `true`, compresses the sending data\n\t\t* @return this Socket\n\t\t*/\n\t\tcompress(compress: boolean):Socket;\n\t}\n\n\t/**\n\t * The Manager static interface\n\t */\n\tinterface ManagerStatic {\n\t\t/**\n\t\t * Creates a new Manager\n\t\t * @param uri The URI that we're connecting to (e.g. http://localhost:4000)\n\t\t * @param opts Any connection options that we want to use (and pass to engine.io)\n\t\t * @return A Manager\n\t\t */\n\t\t( uri: string, opts?: SocketIOClient.ConnectOpts ): SocketIOClient.Manager;\n\t\t\n\t\t/**\n\t\t * Creates a new Manager with the default URI (window host)\n\t\t * @param opts Any connection options that we want to use (and pass to engine.io)\n\t\t */\n\t\t( opts: SocketIOClient.ConnectOpts ):SocketIOClient.Manager;\n\t\t\n\t\t/**\n\t\t * @see default constructor\n\t\t */\n\t\tnew ( uri: string, opts?: SocketIOClient.ConnectOpts ): SocketIOClient.Manager;\n\t\t\n\t\t/**\n\t\t * @see default constructor\n\t\t */\n\t\tnew ( opts: SocketIOClient.ConnectOpts ):SocketIOClient.Manager;\n\t}\n\n\t/**\n\t * The Manager class handles all the Namespaces and Sockets that we're using\n\t */\n\tinterface Manager extends Emitter {\n\t\t\n\t\t/**\n\t\t * All the namespaces currently controlled by this Manager, and the Sockets\n\t\t * that we're using to communicate with them\n\t\t */\n\t\tnsps: { [namespace:string]: Socket };\n\t\t\n\t\t/**\n\t\t * The connect options that we used when creating this Manager\n\t\t */\n\t\topts: SocketIOClient.ConnectOpts;\n\t\t\n\t\t/**\n\t\t * The state of the Manager. Either 'closed', 'opening', or 'open'\n\t\t */\n\t\treadyState: string;\n\t\t\n\t\t/**\n\t\t * The URI that this manager is for (host + port), e.g. 'http://localhost:4000'\n\t\t */\n\t\turi: string;\n\t\t\n\t\t/**\n\t\t * The currently connected sockets\n\t\t */\n\t\tconnecting: Socket[];\n\t\t\n\t\t/**\n\t\t * If we should auto connect (also used when creating Sockets). Set via the\n\t\t * opts object\n\t\t */\n\t\tautoConnect: boolean;\n\t\t\n\t\t/**\n\t\t * Gets if we should reconnect automatically\n\t\t * @default true\n\t\t */\n\t\treconnection(): boolean;\n\t\t\n\t\t/**\n\t\t * Sets if we should reconnect automatically\n\t\t * @param v True if we should reconnect automatically, false otherwise\n\t\t * @default true\n\t\t * @return This Manager\n\t\t */\n\t\treconnection( v: boolean ): Manager;\n\t\t\n\t\t/**\n\t\t * Gets the number of reconnection attempts we should try before giving up\n\t\t * @default Infinity\n\t\t */\n\t\treconnectionAttempts(): number;\n\t\t\n\t\t/**\n\t\t * Sets the number of reconnection attempts we should try before giving up\n\t\t * @param v The number of attempts we should do before giving up\n\t\t * @default Infinity\n\t\t * @return This Manager\n\t\t */\n\t\treconnectionAttempts( v: number ): Manager;\n\t\t\n\t\t/**\n\t\t * Gets the delay in milliseconds between each reconnection attempt\n\t\t * @default 1000\n\t\t */\n\t\treconnectionDelay(): number;\n\t\t\n\t\t/**\n\t\t * Sets the delay in milliseconds between each reconnection attempt\n\t\t * @param v The delay in milliseconds\n\t\t * @default 1000\n\t\t * @return This Manager\n\t\t */\n\t\treconnectionDelay( v: number ): Manager;\n\t\t\n\t\t/**\n\t\t * Gets the max reconnection delay in milliseconds between each reconnection\n\t\t * attempt\n\t\t * @default 5000\n\t\t */\n\t\treconnectionDelayMax(): number;\n\t\t\n\t\t/**\n\t\t * Sets the max reconnection delay in milliseconds between each reconnection\n\t\t * attempt\n\t\t * @param v The max reconnection dleay in milliseconds\n\t\t * @return This Manager\n\t\t */\n\t\treconnectionDelayMax( v: number ): Manager;\n\t\t\n\t\t/**\n\t\t * Gets the randomisation factor used in the exponential backoff jitter \n\t\t * when reconnecting\n\t\t * @default 0.5\n\t\t */\n\t\trandomizationFactor(): number;\n\t\t\n\t\t/**\n\t\t * Sets the randomisation factor used in the exponential backoff jitter \n\t\t * when reconnecting\n\t\t * @param The reconnection randomisation factor\n\t\t * @default 0.5\n\t\t * @return This Manager\n\t\t */\n\t\trandomizationFactor( v: number ): Manager;\n\t\t\n\t\t/**\n\t\t * Gets the timeout in milliseconds for our connection attempts\n\t\t * @default 20000 \n\t\t */\n\t\ttimeout(): number;\n\t\t\n\t\t/**\n\t\t * Sets the timeout in milliseconds for our connection attempts\n\t\t * @param The connection timeout milliseconds\n\t\t * @return This Manager\n\t\t */\n\t\ttimeout(v: boolean): Manager;\n\t\t\n\t\t/**\n\t\t * Sets the current transport socket and opens our connection\n\t\t * @param fn An optional callback to call when our socket has either opened, or\n\t\t * failed. It can take one optional parameter of type Error\n\t\t * @return This Manager\n\t\t */\n\t\topen( fn?: (err?: any) => void ): Manager;\n\t\t\n\t\t/**\n\t\t * @see open( fn );\n\t\t */\n\t\tconnect( fn?: (err?: any) => void ): Manager;\n\t\t\n\t\t/**\n\t\t * Creates a new Socket for the given namespace\n\t\t * @param nsp The namespace that this Socket is for\n\t\t * @return A new Socket, or if one has already been created for this namespace,\n\t\t * an existing one\n\t\t */\n\t\tsocket( nsp: string ): Socket;\n\t}\n\t\t\n\t/**\n\t * Options we can pass to the socket when connecting\n\t */\n\tinterface ConnectOpts {\n\t   \n\t\t/** \n\t\t * Should we force a new Manager for this connection?\n\t\t * @default false \n\t\t */\n\t\tforceNew?: boolean;\n\t   \n\t\t/** \n\t\t * Should we multiplex our connection (reuse existing Manager) ?\n\t\t * @default true\n\t\t */\n\t\tmultiplex?: boolean;\n\t\t\n\t\t/**\n\t\t * The path to get our client file from, in the case of the server\n\t\t * serving it\n\t\t * @default '/socket.io'\n\t\t */\n\t\tpath?: string;\n\t\t\n\t\t/**\n\t\t * Should we allow reconnections?\n\t\t * @default true\n\t\t */\n\t\treconnection?: boolean;\n\t\t\n\t\t/**\n\t\t * How many reconnection attempts should we try?\n\t\t * @default Infinity\n\t\t */\n\t\treconnectionAttempts?: number;\n\t\t\n\t\t/**\n\t\t * The time delay in milliseconds between reconnection attempts\n\t\t * @default 1000\n\t\t */\n\t\treconnectionDelay?: number;\n\t\t\n\t\t/**\n\t\t * The max time delay in milliseconds between reconnection attempts\n\t\t * @default 5000\n\t\t */\n\t\treconnectionDelayMax?: number;\n\t\t\n\t\t/**\n\t\t * Used in the exponential backoff jitter when reconnecting\n\t\t * @default 0.5\n\t\t */\n\t\trandomizationFactor?: number;\n\t\t\n\t\t/**\n\t\t * The timeout in milliseconds for our connection attempt\n\t\t * @default 20000\n\t\t */\n\t\ttimeout?: number;\n\t\t\n\t\t/**\n\t\t * Should we automically connect?\n\t\t * @default true\n\t\t */\n\t\tautoConnect?: boolean;\n\t\t\n\t\t/**\n\t\t * The host that we're connecting to. Set from the URI passed when connecting\n\t\t */\n\t\thost?: string;\n\t\t\n\t\t/**\n\t\t * The hostname for our connection. Set from the URI passed when connecting\n\t\t */\n\t\thostname?: string;\n\t\t\n\t\t/**\n\t\t * If this is a secure connection. Set from the URI passed when connecting\n\t\t */\n\t\tsecure?: boolean;\n\t\t\n\t\t/**\n\t\t * The port for our connection. Set from the URI passed when connecting\n\t\t */\n\t\tport?: string;\n\t\t\n\t\t/**\n\t\t * Any query parameters in our uri. Set from the URI passed when connecting\n\t\t */\n\t\tquery?: Object;\n\t\t\n\t\t/**\n\t\t * `http.Agent` to use, defaults to `false` (NodeJS only)\n\t\t */\n\t\tagent?: string|boolean;\n\t\t\n\t\t/**\n\t\t * Whether the client should try to upgrade the transport from \n\t\t * long-polling to something better.\n\t\t * @default true\n\t\t */\n\t\tupgrade?: boolean;\n\t\t\n\t\t/**\n\t\t * Forces JSONP for polling transport.\n\t\t */\n\t\tforceJSONP?: boolean;\n\t\t\n\t\t/**\n\t\t * Determines whether to use JSONP when necessary for polling. If \n\t\t * disabled (by settings to false) an error will be emitted (saying \n\t\t * \"No transports available\") if no other transports are available. \n\t\t * If another transport is available for opening a connection (e.g. \n\t\t * WebSocket) that transport will be used instead.\n\t\t * @default true\n\t\t */\n\t\tjsonp?: boolean;\n\t\t\n\t\t/**\n\t\t * Forces base 64 encoding for polling transport even when XHR2 \n\t\t * responseType is available and WebSocket even if the used standard \n\t\t * supports binary.\n\t\t */\n\t\tforceBase64?: boolean;\n\t\t\n\t\t/**\n\t\t * Enables XDomainRequest for IE8 to avoid loading bar flashing with \n\t\t * click sound. default to `false` because XDomainRequest has a flaw \n\t\t * of not sending cookie.\n\t\t * @default false\n\t\t */\n\t\tenablesXDR?: boolean;\n\t\t\n\t\t/**\n\t\t * The param name to use as our timestamp key\n\t\t * @default 't'\n\t\t */\n\t\ttimestampParam?: string;\n\t\t\n\t\t/**\n\t\t * Whether to add the timestamp with each transport request. Note: this \n\t\t * is ignored if the browser is IE or Android, in which case requests \n\t\t * are always stamped\n\t\t * @default false\n\t\t */\n\t\ttimestampRequests?: boolean;\n\t\t\n\t\t/**\n\t\t * A list of transports to try (in order). Engine.io always attempts to \n\t\t * connect directly with the first one, provided the feature detection test \n\t\t * for it passes.\n\t\t * @default ['polling','websocket']\n\t\t */\n\t\ttransports?: string[];\n\t\t\n\t\t/**\n\t\t * The port the policy server listens on\n\t\t * @default 843\n\t\t */\n\t\tpolicyPost?: number;\n\t\t\n\t\t/**\n\t\t * If true and if the previous websocket connection to the server succeeded,\n\t\t * the connection attempt will bypass the normal upgrade process and will \n\t\t * initially try websocket. A connection attempt following a transport error \n\t\t * will use the normal upgrade process. It is recommended you turn this on \n\t\t * only when using SSL/TLS connections, or if you know that your network does\n\t\t * not block websockets.\n\t\t * @default false\n\t\t */\n\t\trememberUpgrade?: boolean;\n\t\t\n\t\t/**\n\t\t * Are we only interested in transports that support binary?\n\t\t */\n\t\tonlyBinaryUpgrades?: boolean;\n\t\t\n\t\t/**\n\t\t * (SSL) Certificate, Private key and CA certificates to use for SSL. \n\t\t * Can be used in Node.js client environment to manually specify \n\t\t * certificate information.\n\t\t */\n\t\tpfx?: string;\n\t\t\n\t\t/**\n\t\t * (SSL) Private key to use for SSL. Can be used in Node.js client \n\t\t * environment to manually specify certificate information.\n\t\t */\n\t\tkey?: string;\n\t\t\n\t\t/**\n\t\t * (SSL) A string or passphrase for the private key or pfx. Can be \n\t\t * used in Node.js client environment to manually specify certificate \n\t\t * information.\n\t\t */\n\t\tpassphrase?: string\n\t\t\n\t\t/**\n\t\t * (SSL) Public x509 certificate to use. Can be used in Node.js client \n\t\t * environment to manually specify certificate information.\n\t\t */\n\t\tcert?: string;\n\t\t\n\t\t/**\n\t\t * (SSL) An authority certificate or array of authority certificates to \n\t\t * check the remote host against.. Can be used in Node.js client \n\t\t * environment to manually specify certificate information.\n\t\t */\n\t\tca?: string|string[];\n\t\t\n\t\t/**\n\t\t * (SSL) A string describing the ciphers to use or exclude. Consult the \n\t\t * [cipher format list]\n\t\t * (http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT) for \n\t\t * details on the format.. Can be used in Node.js client environment to \n\t\t * manually specify certificate information.\n\t\t */\n\t\tciphers?: string;\n\t\t\n\t\t/**\n\t\t * (SSL) If true, the server certificate is verified against the list of \n\t\t * supplied CAs. An 'error' event is emitted if verification fails. \n\t\t * Verification happens at the connection level, before the HTTP request \n\t\t * is sent. Can be used in Node.js client environment to manually specify \n\t\t * certificate information.\n\t\t */\n\t\trejectUnauthorized?: boolean;\n\t\t\n\t}\n}\n"
});

},{}]},{},[1]);
