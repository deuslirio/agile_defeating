(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/// <reference path="../../../default/typescript/typescriptAPI/TypeScriptAPIPlugin.d.ts" />
"use strict";

SupCore.system.registerPlugin("typescriptAPI", "p2", {
    code: "",
    defs: "// Type definitions for p2.js v0.7.1\n// Project: https://github.com/schteppe/p2.js/\n// Rev 21/11/2015\n\ndeclare module p2 {\n\n    export class AABB {\n\n        constructor(options?: {\n            upperBound?: number[];\n            lowerBound?: number[];\n        });\n\n        setFromPoints(points: number[][], position: number[], angle: number, skinSize: number): void;\n        copy(aabb: AABB): void;\n        extend(aabb: AABB): void;\n        overlaps(aabb: AABB): boolean;\n\n    }\n\n    export class Broadphase {\n\n        static AABB: number;\n        static BOUNDING_CIRCLE: number;\n\n        static NAIVE: number;\n        static SAP: number;\n\n        static boundingRadiusCheck(bodyA: Body, bodyB: Body): boolean;\n        static aabbCheck(bodyA: Body, bodyB: Body): boolean;\n        static canCollide(bodyA: Body, bodyB: Body): boolean;\n\n        constructor(type: number);\n\n        type: number;\n        result: Body[];\n        world: World;\n        boundingVolumeType: number;\n\n        setWorld(world: World): void;\n        getCollisionPairs(world: World): Body[];\n        boundingVolumeCheck(bodyA: Body, bodyB: Body): boolean;\n\n    }\n\n    export class GridBroadphase extends Broadphase {\n\n        constructor(options?: {\n            xmin?: number;\n            xmax?: number;\n            ymin?: number;\n            ymax?: number;\n            nx?: number;\n            ny?: number;\n        });\n\n        xmin: number;\n        xmax: number;\n        ymin: number;\n        ymax: number;\n        nx: number;\n        ny: number;\n        binsizeX: number;\n        binsizeY: number;\n\n    }\n\n    export class NativeBroadphase extends Broadphase {\n\n    }\n\n    export class Narrowphase {\n\n        contactEquations: ContactEquation[];\n        frictionEquations: FrictionEquation[];\n        enableFriction: boolean;\n        enableEquations: boolean;\n        slipForce: number;\n        frictionCoefficient: number;\n        surfaceVelocity: number;\n        reuseObjects: boolean;\n        resuableContactEquations: any[];\n        reusableFrictionEquations: any[];\n        restitution: number;\n        stiffness: number;\n        relaxation: number;\n        frictionStiffness: number;\n        frictionRelaxation: number;\n        enableFrictionReduction: boolean;\n        contactSkinSize: number;\n\n        collidedLastStep(bodyA: Body, bodyB: Body): boolean;\n        reset(): void;\n        createContactEquation(bodyA: Body, bodyB: Body, shapeA: Shape, shapeB: Shape): ContactEquation;\n        createFrictionFromContact(c: ContactEquation): FrictionEquation;\n\n    }\n\n    export class SAPBroadphase extends Broadphase {\n\n        axisList: Body[];\n        axisIndex: number;\n\n    }\n\n    export class Constraint {\n\n        static DISTANCE: number;\n        static GEAR: number;\n        static LOCK: number;\n        static PRISMATIC: number;\n        static REVOLUTE: number;\n\n        constructor(bodyA: Body, bodyB: Body, type: number, options?: {\n            collideConnected?: boolean;\n        });\n\n        type: number;\n        equeations: Equation[];\n        bodyA: Body;\n        bodyB: Body;\n        collideConnected: boolean;\n\n        update(): void;\n        setStiffness(stiffness: number): void;\n        setRelaxation(relaxation: number): void;\n\n    }\n\n    export class DistanceConstraint extends Constraint {\n\n        constructor(bodyA: Body, bodyB: Body, options?: {\n            distance?: number;\n            localAnchorA?: number[];\n            localAnchorB?: number[];\n            maxForce?: number;\n        });\n\n        localAnchorA: number[];\n        localAnchorB: number[];\n        distance: number;\n        maxForce: number;\n        upperLimitEnabled: boolean;\n        upperLimit: number;\n        lowerLimitEnabled: boolean;\n        lowerLimit: number;\n        position: number;\n\n        setMaxForce(f: number): void;\n        getMaxForce(): number;\n\n    }\n\n    export class GearConstraint extends Constraint {\n\n        constructor(bodyA: Body, bodyB: Body, options?: {\n            angle?: number;\n            ratio?: number;\n            maxTorque?: number;\n        });\n\n        ratio: number;\n        angle: number;\n\n        setMaxTorque(torque: number): void;\n        getMaxTorque(): number;\n\n    }\n\n    export class LockConstraint extends Constraint {\n\n        constructor(bodyA: Body, bodyB: Body, options?: {\n            localOffsetB?: number[];\n            localAngleB?: number;\n            maxForce?: number;\n        });\n\n        setMaxForce(force: number): void;\n        getMaxForce(): number;\n\n    }\n\n    export class PrismaticConstraint extends Constraint {\n\n        constructor(bodyA: Body, bodyB: Body, options?: {\n            maxForce?: number;\n            localAnchorA?: number[];\n            localAnchorB?: number[];\n            localAxisA?: number[];\n            disableRotationalLock?: boolean;\n            upperLimit?: number;\n            lowerLimit?: number;\n        });\n\n        localAnchorA: number[];\n        localAnchorB: number[];\n        localAxisA: number[];\n        position: number;\n        velocity: number;\n        lowerLimitEnabled: boolean;\n        upperLimitEnabled: boolean;\n        lowerLimit: number;\n        upperLimit: number;\n        upperLimitEquation: ContactEquation;\n        lowerLimitEquation: ContactEquation;\n        motorEquation: Equation;\n        motorEnabled: boolean;\n        motorSpeed: number;\n\n        enableMotor(): void;\n        disableMotor(): void;\n        setLimits(lower: number, upper: number): void;\n\n    }\n\n    export class RevoluteConstraint extends Constraint {\n\n        constructor(bodyA: Body, bodyB: Body, options?: {\n            worldPivot?: number[];\n            localPivotA?: number[];\n            localPivotB?: number[];\n            maxForce?: number;\n        });\n\n        pivotA: number[];\n        pivotB: number[];\n        motorEquation: RotationalVelocityEquation;\n        motorEnabled: boolean;\n        angle: number;\n        lowerLimitEnabled: boolean;\n        upperLimitEnabled: boolean;\n        lowerLimit: number;\n        upperLimit: number;\n        upperLimitEquation: ContactEquation;\n        lowerLimitEquation: ContactEquation;\n\n        enableMotor(): void;\n        disableMotor(): void;\n        motorIsEnabled(): boolean;\n        setLimits(lower: number, upper: number): void;\n        setMotorSpeed(speed: number): void;\n        getMotorSpeed(): number;\n\n    }\n\n    export class WheelConstraint extends Constraint {\n        constructor(vehicle: TopDownVehicle, options?: {\n            localForwardVector?: number[],\n            localPosition?: number[],\n            sideFriction?: number\n        });\n        setBrakeForce(number): void;\n        setSideFriction(number): void;\n        getSpeed(): number;\n        update(): void;\n\n        vehicle: TopDownVehicle;\n        steerValue: number;\n        engineForce: number;\n        localForwardVector: number[];\n        localPosition: number[];\n\n    }\n\n    export class AngleLockEquation extends Equation {\n\n        constructor(bodyA: Body, bodyB: Body, options?: {\n            angle?: number;\n            ratio?: number;\n        });\n\n        computeGq(): number;\n        setRatio(ratio: number): number;\n        setMaxTorque(torque: number): number;\n\n    }\n\n    export class ContactEquation extends Equation {\n\n        constructor(bodyA: Body, bodyB: Body);\n\n        contactPointA: number[];\n        penetrationVec: number[];\n        contactPointB: number[];\n        normalA: number[];\n        restitution: number;\n        firstImpact: boolean;\n        shapeA: Shape;\n        shapeB: Shape;\n\n        computeB(a: number, b: number, h: number): number;\n\n    }\n\n    export class Equation {\n\n        static DEFAULT_STIFFNESS: number;\n        static DEFAULT_RELAXATION: number;\n\n        constructor(bodyA: Body, bodyB: Body, minForce?: number, maxForce?: number);\n\n        minForce: number;\n        maxForce: number;\n        bodyA: Body;\n        bodyB: Body;\n        stiffness: number;\n        relaxation: number;\n        G: number[];\n        offset: number;\n        a: number;\n        b: number;\n        epsilon: number;\n        timeStep: number;\n        needsUpdate: boolean;\n        multiplier: number;\n        relativeVelocity: number;\n        enabled: boolean;\n\n        gmult(G: number[], vi: number[], wi: number[], vj: number[], wj: number[]): number;\n        computeB(a: number, b: number, h: number): number;\n        computeGq(): number;\n        computeGW(): number;\n        computeGWlambda(): number;\n        computeGiMf(): number;\n        computeGiMGt(): number;\n        addToWlambda(deltalambda: number): number;\n        computeInvC(eps: number): number;\n\n    }\n\n    export class FrictionEquation extends Equation {\n\n        constructor(bodyA: Body, bodyB: Body, slipForce: number);\n\n        contactPointA: number[];\n        contactPointB: number[];\n        t: number[];\n        shapeA: Shape;\n        shapeB: Shape;\n        frictionCoefficient: number;\n\n        setSlipForce(slipForce: number): number;\n        getSlipForce(): number;\n        computeB(a: number, b: number, h: number): number;\n\n    }\n\n    export class RotationalLockEquation extends Equation {\n\n        constructor(bodyA: Body, bodyB: Body, options?: {\n            angle?: number;\n        });\n\n        angle: number;\n\n        computeGq(): number;\n\n    }\n\n    export class RotationalVelocityEquation extends Equation {\n\n        constructor(bodyA: Body, bodyB: Body);\n\n        computeB(a: number, b: number, h: number): number;\n\n    }\n\n    export class EventEmitter {\n\n        on(type: string, listener: Function, context: any): EventEmitter;\n        has(type: string, listener: Function): boolean;\n        off(type: string, listener: Function): EventEmitter;\n        emit(event: any): EventEmitter;\n\n    }\n\n    export class ContactMaterialOptions {\n\n        friction: number;\n        restitution: number;\n        stiffness: number;\n        relaxation: number;\n        frictionStiffness: number;\n        frictionRelaxation: number;\n        surfaceVelocity: number;\n\n    }\n\n    export class ContactMaterial {\n\n        static idCounter: number;\n\n        constructor(materialA: Material, materialB: Material, options?: ContactMaterialOptions);\n\n        id: number;\n        materialA: Material;\n        materialB: Material;\n        friction: number;\n        restitution: number;\n        stiffness: number;\n        relaxation: number;\n        frictionStuffness: number;\n        frictionRelaxation: number;\n        surfaceVelocity: number;\n        contactSkinSize: number;\n\n    }\n\n    export class Material {\n\n        static idCounter: number;\n\n        constructor(id: number);\n\n        id: number;\n\n    }\n\n    export class vec2 {\n\n        static crossLength(a: number[], b: number[]): number;\n        static crossVZ(out: number[], vec: number[], zcomp: number): number;\n        static crossZV(out: number[], zcomp: number, vec: number[]): number;\n        static rotate(out: number[], a: number[], angle: number): void;\n        static rotate90cw(out: number[], a: number[]): number;\n        static centroid(out: number[], a: number[], b: number[], c: number[]): number[];\n        static create(): number[];\n        static clone(a: number[]): number[];\n        static fromValues(x: number, y: number): number[];\n        static copy(out: number[], a: number[]): number[];\n        static set(out: number[], x: number, y: number): number[];\n        static toLocalFrame(out: number[], worldPoint: number[], framePosition: number[], frameAngle: number): void;\n        static toGlobalFrame(out: number[], localPoint: number[], framePosition: number[], frameAngle: number): void;\n        static add(out: number[], a: number[], b: number[]): number[];\n        static subtract(out: number[], a: number[], b: number[]): number[];\n        static sub(out: number[], a: number[], b: number[]): number[];\n        static multiply(out: number[], a: number[], b: number[]): number[];\n        static mul(out: number[], a: number[], b: number[]): number[];\n        static divide(out: number[], a: number[], b: number[]): number[];\n        static div(out: number[], a: number[], b: number[]): number[];\n        static scale(out: number[], a: number[], b: number): number[];\n        static distance(a: number[], b: number[]): number;\n        static dist(a: number[], b: number[]): number;\n        static squaredDistance(a: number[], b: number[]): number;\n        static sqrDist(a: number[], b: number[]): number;\n        static length(a: number[]): number;\n        static len(a: number[]): number;\n        static squaredLength(a: number[]): number;\n        static sqrLen(a: number[]): number;\n        static negate(out: number[], a: number[]): number[];\n        static normalize(out: number[], a: number[]): number[];\n        static dot(a: number[], b: number[]): number;\n        static str(a: number[]): string;\n\n    }\n\n    export interface BodyOptions {\n\n        mass?: number;\n        position?: number[];\n        velocity?: number[];\n        angle?: number;\n        angularVelocity?: number;\n        force?: number[];\n        angularForce?: number;\n        fixedRotation?: boolean;\n\n    }\n\n    export class Body extends EventEmitter {\n\n        sleepyEvent: {\n            type: string;\n        };\n\n        sleepEvent: {\n            type: string;\n        };\n\n        wakeUpEvent: {\n            type: string;\n        };\n\n        static DYNAMIC: number;\n        static STATIC: number;\n        static KINEMATIC: number;\n        static AWAKE: number;\n        static SLEEPY: number;\n        static SLEEPING: number;\n\n        constructor(options?: BodyOptions);\n\n        id: number;\n        world: World;\n        shapes: Shape[];\n        mass: number;\n        invMass: number;\n        inertia: number;\n        invInertia: number;\n        invMassSolve: number;\n        invInertiaSolve: number;\n        fixedRotation: boolean;\n        fixedX: boolean;\n        fixedY: boolean;\n        massMultiplier: number[];\n        position: number[];\n        interpolatedPosition: number[];\n        interpolatedAngle: number;\n        previousPosition: number[];\n        previousAngle: number;\n        velocity: number[];\n        vlambda: number[];\n        wlambda: number[];\n        angle: number;\n        angularVelocity: number;\n        force: number[];\n        angularForce: number;\n        damping: number;\n        angularDamping: number;\n        type: number;\n        boundingRadius: number;\n        aabb: AABB;\n        aabbNeedsUpdate: boolean;\n        allowSleep: boolean;\n        wantsToSleep: boolean;\n        sleepState: number;\n        sleepSpeedLimit: number;\n        sleepTimeLimit: number;\n        gravityScale: number;\n        collisionResponse: boolean;\n        idleTime: number;\n        timeLastSleepy: number;\n        ccdSpeedThreshold: number;\n        ccdIterations: number;\n\n        updateSolveMassProperties(): void;\n        setDensity(density: number): void;\n        getArea(): number;\n        getAABB(): AABB;\n        updateAABB(): void;\n        updateBoundingRadius(): void;\n        addShape(shape: Shape, offset?: number[], angle?: number): void;\n        removeShape(shape: Shape): boolean;\n        updateMassProperties(): void;\n        applyForce(force: number[], worldPoint: number[]): void;\n        applyForceLocal(localForce: number[], localPoint: number[]): void;\n        applyImpulse(impulseVector: number[], relativePoint: number[]): void;\n        applyImpulseLocal(localImpulse: number[], localPoint: number[]): void;\n        toLocalFrame(out: number[], worldPoint: number[]): void;\n        toWorldFrame(out: number[], localPoint: number[]): void;\n        vectorToLocalFrame(out: number[], worldVector: number[]): void;\n        vectorToWorldFrame(out: number[], localVector: number[]): void;\n        fromPolygon(path: number[][], options?: {\n            optimalDecomp?: boolean;\n            skipSimpleCheck?: boolean;\n            removeCollinearPoints?: any; //boolean | number\n        }): boolean;\n        adjustCenterOfMass(): void;\n        setZeroForce(): void;\n        resetConstraintVelocity(): void;\n        addConstraintVelocity(): void;\n        applyDamping(dy: number): void;\n        wakeUp(): void;\n        sleep(): void;\n        sleepTick(time: number, dontSleep: boolean, dt: number): void;\n        overlaps(body: Body): boolean;\n        integrate(dt: number): void;\n        integrateToTimeOfImpact(dt: number): void;\n        getVelocityAtPoint(result: number[], relativePoint: number[]): number[];\n    }\n\n    export class Spring {\n\n        constructor(bodyA: Body, bodyB: Body, options?: {\n\n            stiffness?: number;\n            damping?: number;\n            localAnchorA?: number[];\n            localAnchorB?: number[];\n            worldAnchorA?: number[];\n            worldAnchorB?: number[];\n\n        });\n\n        stiffness: number;\n        damping: number;\n        bodyA: Body;\n        bodyB: Body;\n\n        applyForce(): void;\n\n    }\n\n    export class LinearSpring extends Spring {\n\n        localAnchorA: number[];\n        localAnchorB: number[];\n        restLength: number;\n\n        setWorldAnchorA(worldAnchorA: number[]): void;\n        setWorldAnchorB(worldAnchorB: number[]): void;\n        getWorldAnchorA(result: number[]): number[];\n        getWorldAnchorB(result: number[]): number[];\n        applyForce(): void;\n\n    }\n\n    export class RotationalSpring extends Spring {\n\n        constructor(bodyA: Body, bodyB: Body, options?: {\n            restAngle?: number;\n            stiffness?: number;\n            damping?: number;\n        });\n\n        restAngle: number;\n\n    }\n\n    export class TopDownVehicle {\n        constructor(chassiBody: Body, options?: {});\n        addToWorld(world: World): void;\n        removeFromWorld(): void;\n        addWheel(wheelOptions?: {\n            localForwardVector?: number[],\n            localPosition?: number[],\n            sideFriction?: number\n        }): WheelConstraint;\n        update(): void;\n\n        chassisBody: Body;\n        wheels: WheelConstraint[];\n\n    }\n\n    export interface CapsuleOptions extends SharedShapeOptions {\n\n      length?: number;\n      radius?: number;\n\n    }\n\n    export class Capsule extends Shape {\n\n        constructor(options?: CapsuleOptions);\n\n        length: number;\n        radius: number;\n\n    }\n\n    export interface CircleOptions extends SharedShapeOptions {\n\n      radius?: number;\n\n    }\n\n    export class Circle extends Shape {\n\n        constructor(options?: CircleOptions);\n\n        radius: number;\n\n    }\n\n    export interface ConvexOptions extends SharedShapeOptions {\n\n      length?: number;\n      radius?: number;\n\n    }\n\n    export class Convex extends Shape {\n\n        static triangleArea(a: number[], b: number[], c: number[]): number;\n\n        constructor(options?: ConvexOptions);\n\n        vertices: number[][];\n        axes: number[];\n        centerOfMass: number[];\n        triangles: number[];\n        boundingRadius: number;\n\n        projectOntoLocalAxis(localAxis: number[], result: number[]): void;\n        projectOntoWorldAxis(localAxis: number[], shapeOffset: number[], shapeAngle: number, result: number[]): void;\n\n        updateCenterOfMass(): void;\n\n    }\n\n    export interface HeightfieldOptions extends SharedShapeOptions {\n\n        heights?: number[];\n        minValue?: number;\n        maxValue?: number;\n        elementWidth?: number;\n\n    }\n\n    export class Heightfield extends Shape {\n\n        constructor(options?: HeightfieldOptions);\n\n        data: number[];\n        maxValue: number;\n        minValue: number;\n        elementWidth: number;\n\n    }\n\n    export interface SharedShapeOptions {\n\n        position?: number[];\n        angle?: number;\n        collisionGroup?: number;\n        collisionResponse?: boolean;\n        collisionMask?: number;\n        sensor?: boolean;\n\n    }\n\n    export interface ShapeOptions extends SharedShapeOptions {\n\n        type?: number;\n\n    }\n\n    export class Shape {\n\n        static idCounter: number;\n        static CIRCLE: number;\n        static PARTICLE: number;\n        static PLANE: number;\n        static CONVEX: number;\n        static LINE: number;\n        static BOX: number;\n        static CAPSULE: number;\n        static HEIGHTFIELD: number;\n\n        constructor(options?: ShapeOptions);\n\n        type: number;\n        id: number;\n        position: number[];\n        angle: number;\n        boundingRadius: number;\n        collisionGroup: number;\n        collisionResponse: boolean;\n        collisionMask: number;\n        material: Material;\n        area: number;\n        sensor: boolean;\n\n        computeMomentOfInertia(mass: number): number;\n        updateBoundingRadius(): number;\n        updateArea(): void;\n        computeAABB(out: AABB, position: number[], angle: number): void;\n\n    }\n\n    export interface LineOptions extends SharedShapeOptions {\n\n      length?: number;\n\n    }\n\n    export class Line extends Shape {\n\n        constructor(options?: LineOptions);\n\n        length: number;\n\n    }\n\n    export class Particle extends Shape {\n\n        constructor(options?: SharedShapeOptions);\n\n    }\n\n    export class Plane extends Shape {\n\n        constructor(options?: SharedShapeOptions);\n\n    }\n\n    export interface BoxOptions {\n\n      width?: number;\n      height?: number;\n\n    }\n\n    export class Box extends Shape {\n\n        constructor(options?: BoxOptions);\n\n        width: number;\n        height: number;\n\n    }\n\n    export class Solver extends EventEmitter {\n\n        static GS: number;\n        static ISLAND: number;\n\n        constructor(options?: {}, type?: number);\n\n        type: number;\n        equations: Equation[];\n        equationSortFunction: Equation; //Equation | boolean\n\n        solve(dy: number, world: World): void;\n        solveIsland(dy: number, island: Island): void;\n        sortEquations(): void;\n        addEquation(eq: Equation): void;\n        addEquations(eqs: Equation[]): void;\n        removeEquation(eq: Equation): void;\n        removeAllEquations(): void;\n\n    }\n\n    export class GSSolver extends Solver {\n\n        constructor(options?: {\n            iterations?: number;\n            tolerance?: number;\n        });\n\n        iterations: number;\n        tolerance: number;\n        useZeroRHS: boolean;\n        frictionIterations: number;\n        usedIterations: number;\n\n        solve(h: number, world: World): void;\n\n    }\n\n    export class OverlapKeeper {\n\n        constructor(bodyA: Body, shapeA: Shape, bodyB: Body, shapeB: Shape);\n\n        shapeA: Shape;\n        shapeB: Shape;\n        bodyA: Body;\n        bodyB: Body;\n\n        tick(): void;\n        setOverlapping(bodyA: Body, shapeA: Shape, bodyB: Body, shapeB: Body): void;\n        bodiesAreOverlapping(bodyA: Body, bodyB: Body): boolean;\n        set(bodyA: Body, shapeA: Shape, bodyB: Body, shapeB: Shape): void;\n\n    }\n\n    export class TupleDictionary {\n\n        data: number[];\n        keys: number[];\n\n        getKey(id1: number, id2: number): string;\n        getByKey(key: number): number;\n        get(i: number, j: number): number;\n        set(i: number, j: number, value: number): number;\n        reset(): void;\n        copy(dict: TupleDictionary): void;\n\n    }\n\n    export class Utils {\n\n        static appendArray<T>(a: Array<T>, b: Array<T>): Array<T>;\n        static splice<T>(array: Array<T>, index: number, howMany: number): void;\n        static extend(a: any, b: any): void;\n        static defaults(options: any, defaults: any): any;\n\n    }\n\n    export class Island {\n\n        equations: Equation[];\n        bodies: Body[];\n\n        reset(): void;\n        getBodies(result: any): Body[];\n        wantsToSleep(): boolean;\n        sleep(): boolean;\n\n    }\n\n    export class IslandManager extends Solver {\n\n        static getUnvisitedNode(nodes: IslandNode[]): IslandNode; // IslandNode | boolean\n\n        equations: Equation[];\n        islands: Island[];\n        nodes: IslandNode[];\n\n        visit(node: IslandNode, bds: Body[], eqs: Equation[]): void;\n        bfs(root: IslandNode, bds: Body[], eqs: Equation[]): void;\n        split(world: World): Island[];\n\n    }\n\n    export class IslandNode {\n\n        constructor(body: Body);\n\n        body: Body;\n        neighbors: IslandNode[];\n        equations: Equation[];\n        visited: boolean;\n\n        reset(): void;\n\n    }\n\n    export class World extends EventEmitter {\n\n        postStepEvent: {\n            type: string;\n        };\n\n        addBodyEvent: {\n            type: string;\n        };\n\n        removeBodyEvent: {\n            type: string;\n        };\n\n        addSpringEvent: {\n            type: string;\n        };\n\n        impactEvent: {\n            type: string;\n            bodyA: Body;\n            bodyB: Body;\n            shapeA: Shape;\n            shapeB: Shape;\n            contactEquation: ContactEquation;\n        };\n\n        postBroadphaseEvent: {\n            type: string;\n            pairs: Body[];\n        };\n\n        beginContactEvent: {\n            type: string;\n            shapeA: Shape;\n            shapeB: Shape;\n            bodyA: Body;\n            bodyB: Body;\n            contactEquations: ContactEquation[];\n        };\n\n        endContactEvent: {\n            type: string;\n            shapeA: Shape;\n            shapeB: Shape;\n            bodyA: Body;\n            bodyB: Body;\n        };\n\n        preSolveEvent: {\n            type: string;\n            contactEquations: ContactEquation[];\n            frictionEquations: FrictionEquation[];\n        };\n\n        static NO_SLEEPING: number;\n        static BODY_SLEEPING: number;\n        static ISLAND_SLEEPING: number;\n\n        static integrateBody(body: Body, dy: number): void;\n\n        constructor(options?: {\n            solver?: Solver;\n            gravity?: number[];\n            broadphase?: Broadphase;\n            islandSplit?: boolean;\n            doProfiling?: boolean;\n        });\n\n        springs: Spring[];\n        bodies: Body[];\n        solver: Solver;\n        narrowphase: Narrowphase;\n        islandManager: IslandManager;\n        gravity: number[];\n        frictionGravity: number;\n        useWorldGravityAsFrictionGravity: boolean;\n        useFrictionGravityOnZeroGravity: boolean;\n        doProfiling: boolean;\n        lastStepTime: number;\n        broadphase: Broadphase;\n        constraints: Constraint[];\n        defaultMaterial: Material;\n        defaultContactMaterial: ContactMaterial;\n        lastTimeStep: number;\n        applySpringForces: boolean;\n        applyDamping: boolean;\n        applyGravity: boolean;\n        solveConstraints: boolean;\n        contactMaterials: ContactMaterial[];\n        time: number;\n        stepping: boolean;\n        islandSplit: boolean;\n        emitImpactEvent: boolean;\n        sleepMode: number;\n\n        addConstraint(c: Constraint): void;\n        addContactMaterial(contactMaterial: ContactMaterial): void;\n        removeContactMaterial(cm: ContactMaterial): void;\n        getContactMaterial(materialA: Material, materialB: Material): ContactMaterial; // ContactMaterial | boolean\n        removeConstraint(c: Constraint): void;\n        step(dy: number, timeSinceLastCalled?: number, maxSubSteps?: number): void;\n        runNarrowphase(np: Narrowphase, bi: Body, si: Shape, xi: any[], ai: number, bj: Body, sj: Shape, xj: any[], aj: number, cm: number, glen: number): void;\n        addSpring(s: Spring): void;\n        removeSpring(s: Spring): void;\n        addBody(body: Body): void;\n        removeBody(body: Body): void;\n        getBodyByID(id: number): Body; //Body | boolean\n        disableBodyCollision(bodyA: Body, bodyB: Body): void;\n        enableBodyCollision(bodyA: Body, bodyB: Body): void;\n        clear(): void;\n        clone(): World;\n        hitTest(worldPoint: number[], bodies: Body[], precision: number): Body[];\n        setGlobalEquationParameters(parameters: {\n            relaxation?: number;\n            stiffness?: number;\n        }): void;\n        setGlobalStiffness(stiffness: number): void;\n        setGlobalRelaxation(relaxation: number): void;\n    }\n\n}\n",
});
SupCore.system.registerPlugin("typescriptAPI", "P2Body", {
    code: "namespace Sup {\n  export namespace P2 {\n    export function getWorld() { return SupEngine.P2.world; }\n    export function resetWorld() { SupEngine.P2.world = new window.p2.World(); }\n    export function getWorldAutoUpdate() { return SupEngine.P2.autoUpdate; }\n    export function setWorldAutoUpdate(autoUpdate) { SupEngine.P2.autoUpdate = autoUpdate; }\n\n    export class Body extends ActorComponent {\n      body: any;\n\n      constructor( actor, options ) {\n        super( actor );\n        this.__inner = new SupEngine.componentClasses.P2Body(actor.__inner);\n        if (options != null) this.__inner.setup(options);\n        this.__inner.__outer = this;\n        this.body = this.__inner.body;\n        this.actor.p2Body = this;\n      }\n      destroy() {\n        this.body = null;\n        this.actor.p2Body = null;\n        super.destroy();\n      }\n    }\n  }\n}\n",
    defs: "declare namespace Sup {\n  namespace P2 {\n    function getWorld(): p2.World;\n    function resetWorld();\n    function getWorldAutoUpdate(): boolean;\n    function setWorldAutoUpdate(autoUpdate: boolean);\n\n    class Body extends ActorComponent {\n      body: p2.Body;\n\n      constructor(actor: Sup.Actor, options: any);\n    }\n  }\n}\n",
    exposeActorComponent: { propertyName: "p2Body", className: "Sup.P2.Body" }
});

},{}]},{},[1]);
