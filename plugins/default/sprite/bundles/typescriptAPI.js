(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/// <reference path="../../typescript/typescriptAPI/TypeScriptAPIPlugin.d.ts" />
"use strict";

SupCore.system.registerPlugin("typescriptAPI", "Sup.Sprite", {
    code: "namespace Sup {\n  export class Sprite extends Asset {\n    getPixelsPerUnit() { return this.__inner.pixelsPerUnit; }\n    getRendering() { return this.__inner.filtering; }\n    getFramesPerSecond() { return this.__inner.framesPerSecond; }\n    getAlphaTest() { return this.__inner.alphaTest; }\n    getGridSize() { return { width: this.__inner.grid.width, height: this.__inner.grid.height }; }\n    getOrigin() { return new Sup.Math.Vector2(this.__inner.origin.x * 100, this.__inner.origin.y * 100); }\n    getAnimationList() {\n      let animations = [];\n      for (let animation of this.__inner.animations) animations.push(animation.name);\n      return animations;\n    }\n  }\n}\n",
    defs: "declare namespace Sup {\n  class Sprite extends Asset {\n    dummySpriteMember;\n\n    getPixelsPerUnit(): number;\n    getRendering(): string;\n    getFramesPerSecond(): number;\n    getAlphaTest(): number;\n    getGridSize(): { width: number; height: number; };\n    getOrigin(): Sup.Math.Vector2;\n    getAnimationList(): string[];\n  }\n}\n",
});
SupCore.system.registerPlugin("typescriptAPI", "SpriteRenderer", {
    code: "namespace Sup {\n  let materialTypes = [\"basic\", \"phong\", \"shader\"];\n\n  export class SpriteRenderer extends Sup.ActorComponent {\n    constructor(actor: Actor, pathOrAsset?: string|Sprite, materialIndex?: number, shaderPathOrAsset?: string|Shader) {\n      super(actor);\n      this.__inner = new SupEngine.componentClasses.SpriteRenderer(this.actor.__inner);\n      if (pathOrAsset != null) this.setSprite(pathOrAsset, materialIndex, shaderPathOrAsset);\n      this.__inner.__outer = this;\n      this.actor.spriteRenderer = this;\n    }\n    destroy() {\n      this.actor.spriteRenderer = null;\n      super.destroy();\n    }\n\n    getSprite() { return (this.__inner.asset != null) ? this.__inner.asset.__outer : null; }\n    setSprite(pathOrAsset: string|Sprite, materialIndex?: number, shaderPathOrAsset?: string|Shader) {\n      let material: string;\n      if (materialIndex != null) material = materialTypes[materialIndex];\n\n      if (material === \"shader\" && shaderPathOrAsset == null) {\n        throw new Error(`Shader asset is missing when setting sprite on actor named \"${this.actor.getName()}\"`);\n      }\n\n      let spriteAsset: Sprite;\n      if (pathOrAsset != null) {\n        spriteAsset = (typeof pathOrAsset === \"string\") ? get(pathOrAsset, Sprite) : <Sprite>pathOrAsset;\n        this.__inner.opacity = spriteAsset.__inner.opacity;\n      }\n      let shaderAsset: Shader;\n      if (shaderPathOrAsset != null)\n        shaderAsset = (typeof shaderPathOrAsset === \"string\") ? get(shaderPathOrAsset, Shader) : <Shader>shaderPathOrAsset;\n\n      this.__inner.setSprite((spriteAsset != null) ? spriteAsset.__inner : null, material, (shaderAsset != null) ? shaderAsset.__inner : null);\n      return this;\n    }\n    \n    getMaterialType() { return materialTypes.indexOf(this.__inner.materialType); }\n    getShader() { return this.__inner.materialType === \"shader\" ? this.__inner.shaderAsset.__outer : null; }\n    uniforms = new Sup.ShaderUniforms(this);\n\n    setHorizontalFlip(horizontalFlip) { this.__inner.setHorizontalFlip(horizontalFlip); return this; }\n    getHorizontalFlip() { return this.__inner.horizontalFlip; }\n    setVerticalFlip(verticalFlip) { this.__inner.setVerticalFlip(verticalFlip); return this; }\n    getVerticalFlip() { return this.__inner.verticalFlip; }\n    getOpacity() { return this.__inner.opacity; }\n    setOpacity(opacity) { this.__inner.setOpacity(opacity); return this; }\n    getColor() { return new Color(this.__inner.color.r, this.__inner.color.g, this.__inner.color.b); }\n    setColor(r, g, b) {\n      if (g == null && b == null) {\n        let color = r;\n        this.__inner.setColor(color.r, color.g, color.b);\n      } else this.__inner.setColor(r, g, b);\n      return this;\n    }\n\n    setAnimation(animationName, looping) { this.__inner.setAnimation(animationName, looping); return this; }\n    getAnimation() { return this.__inner.getAnimation(); }\n    setAnimationFrameTime(frametime) { this.__inner.setAnimationFrameTime(frametime); return this; }\n    getAnimationFrameTime() { return this.__inner.getAnimationFrameTime(); }\n    getAnimationFrameIndex() { return this.__inner.getAnimationFrameIndex(); }\n    getAnimationFrameCount() { return this.__inner.getAnimationFrameCount(); }\n    getAnimationSpeed() { return this.__inner.animation != null ? this.__inner.animation.speed : null; }\n\n    isAnimationPlaying() { return this.__inner.isAnimationPlaying; }\n    playAnimation(looping) { this.__inner.playAnimation(looping); return this; }\n    pauseAnimation() { this.__inner.pauseAnimation(); return this; }\n    stopAnimation() { this.__inner.stopAnimation(); return this; }\n    setPlaybackSpeed(playbackSpeed) { this.__inner.playbackSpeed = playbackSpeed; return this; }\n    getPlaybackSpeed() { return this.__inner.playbackSpeed; }\n  }\n\n  export namespace SpriteRenderer {\n    export enum MaterialType { Basic, Phong, Shader };\n  }\n}\n",
    defs: "declare namespace Sup {\n  class SpriteRenderer extends ActorComponent {\n    constructor(actor: Actor, pathOrAsset?: string|Sprite);\n    constructor(actor: Actor, pathOrAsset: string|Sprite, materialType?: SpriteRenderer.MaterialType, shaderPathOrAsset?: string|Shader);\n\n    getSprite(): Sprite;\n    setSprite(pathOrAsset: string|Sprite): SpriteRenderer;\n    setSprite(pathOrAsset: string|Sprite, materialType?: SpriteRenderer.MaterialType, shaderPathOrAsset?: string|Shader): SpriteRenderer;\n    \n    getMaterialType(): SpriteRenderer.MaterialType;\n    getShader(): Shader;\n    uniforms: Sup.ShaderUniforms;\n\n    setHorizontalFlip(horizontalFlip: boolean): SpriteRenderer;\n    getHorizontalFlip(): boolean;\n    setVerticalFlip(verticalFlip: boolean): SpriteRenderer;\n    getVerticalFlip(): boolean;\n    getOpacity(): number;\n    setOpacity(opacity: number): SpriteRenderer;\n    getColor(): Sup.Color;\n    setColor(color: Sup.Color): SpriteRenderer;\n    setColor(r: number, g: number, b: number): SpriteRenderer;\n\n    getAnimation(): string;\n    setAnimation(animationName: string, looping?: boolean): SpriteRenderer;\n    setAnimationFrameTime(frameTime: number): SpriteRenderer;\n    getAnimationFrameTime(): number;\n    getAnimationFrameIndex(): number;\n    getAnimationFrameCount(): number;\n    getAnimationSpeed(): number;\n\n    isAnimationPlaying(): boolean;\n    playAnimation(looping?: boolean): SpriteRenderer;\n    pauseAnimation(): SpriteRenderer;\n    stopAnimation(): SpriteRenderer;\n    setPlaybackSpeed(playbackSpeed: number): SpriteRenderer;\n    getPlaybackSpeed();\n  }\n\n  namespace SpriteRenderer {\n    enum MaterialType { Basic, Phong, Shader }\n  }\n}\n",
    exposeActorComponent: { propertyName: "spriteRenderer", className: "Sup.SpriteRenderer" }
});

},{}]},{},[1]);
